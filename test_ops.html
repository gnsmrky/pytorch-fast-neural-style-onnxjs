<html>
    
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PyTorch fast-neural-style running in web browser</title>

<script>
        const cOnnxjsVersion="v0.1.5"; // set this to the same version string as in npm url for onnx.min.js
</script>
<script src="https://cdn.jsdelivr.net/npm/onnxjs@0.1.5/dist/onnx.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/ua-parser-js@0/dist/ua-parser.min.js"></script>

<body onload="htmlGenerateUI()">
<font face="verdana">
<h1>ONNX.js op test</h1>

<table>
    <tr>
        <td align='right'>Backend:<br/>&nbsp;</td>
        <td>
            <select id="backendSelectElem" onchange="htmlOnBackendSelectChange()">
                <option value='webgl'  selected='selected'>WebGL</option>
                <option value='cpu'>CPU</option>
                <option value='cpu'>Web Assembly</option>
            </select>
            <br/>&nbsp;
        </td>
    </tr>
    <tr>
        <td align='right'>ONNX Op model:</td>
        <td>
            <select id="opModelSelectElem" onchange="htmlOnOpModelSelectChange()"></select>
        </td>
    </tr>
    <tr>
        <td align='right' valign='top'>ONNX Graph:</td>
        <td><img id='onnxGraphElem' width='100px' src=''/></td>
    </tr>
</table>

<br/>

<input type="button" id="testButtonElem" value="Run Op Test" onclick="htmlOnRunOpTest()"/>

<p>
<div id='logOutputDiv'></div>
</p>

<p>
<table>
    <tr>
        <td><div id="copyButtonDiv"></div></td>
        <td>&nbsp;&nbsp;</td>
        <td><div id="postLinkDiv"></div></td>
    </tr>
</table>
</p>

<p>
<div id="logAllOutputDiv"></div>
</p>

</font>

<script>
const cBackendSelectId = "backendSelectElem";
const cOpModelSelectId = "opModelSelectElem";

const cModelList = [
    { name: "Conv2d"                        , model_url: "./onnx_test/test_conv2d_128x128.onnx" },
    { name: "Pad 'Reflection' mode"         , model_url: "./onnx_test/test_pad_reflect_128x128.onnx" },
    { name: "Pad 'Reflection' mode + Conv2D", model_url: "./onnx_test/test_pad_reflect_conv2d_128x128.onnx" },
    { name: "Pad 'Zero' mode"               , model_url: "./onnx_test/test_pad_zero_128x128.onnx" },
];


const cNewLine = String.fromCharCode(13, 10);

function uaIsMobile() {
  var uap = new UAParser();
  uap.setUA(navigator.userAgent);

  var uapRes = uap.getResult();
  const osName = uapRes.os.name.toLowerCase();

  return (osName.indexOf("ios") >=0) || (osName.indexOf("android") >= 0);
}

function asyncSetHtml (elemNode, html) {
  var p = new Promise( (resolve, reject) => {
    elemNode.innerHTML = html;
    setTimeout (resolve, 0);
  });

  return p;
}

function htmlClearUI (){
    logOutputDiv.innerHTML  = "";
    copyButtonDiv.innerHTML = "";
    postLinkDiv.innerHTML = "";
}

function htmlGenerateUI () {
    htmlGenerateModelList(opModelSelectElem);
}

function htmlGenerateModelList (listElem) {
    listElem.innerHTML = "";
    const list = cModelList;
    for (i=0; i<list.length; i++) {
        if (i==0) {
            listElem.innerHTML += "<option value='" + i + "' selected='selected'>" + list[i].name + "</option>";
        } else {
            listElem.innerHTML += "<option value='" + i + "'>" + list[i].name + "</option>";
        }
    }

    onnxGraphElem.src = list[0].model_url + ".png";
}

function htmlOnBackendSelectChange() {
    htmlClearUI();
}

function htmlOnOpModelSelectChange() {
    htmlClearUI();

    const modelIdx = opModelSelectElem.value;
    
    const list = cModelList;
    onnxGraphElem.src = list[modelIdx].model_url + ".png";
}

function htmlOnCopyToClipboard (textAreaElem) {
    //outputElem = document.getElementById(textAreaId);
    textAreaElem.select();
    document.execCommand("copy");

    // add post link only after "copy" command is done
    isMobile = uaIsMobile();
    issueIdx = isMobile ? 2 : 1;
    issueTypeStr = isMobile ? "mobile" : "desktop";
    postLinkDiv.innerHTML = "<a href='https://github.com/gnsmrky/pytorch-fast-neural-style-onnxjs/issues/" + issueIdx + "'>Post/paste the result here for " + issueTypeStr + "</a>";
}

function htmlOnRunOpTest() {
    inferResultStr  = "Description:" + cNewLine;
    inferResultStr += cNewLine + cNewLine + cNewLine;

    // log browser info
    var uap = new UAParser();
    const uaStr = navigator.userAgent;
    
    // test UA string from Pixel 3.  UAParser() only returns 'Pixel'.
    //const uaStr = "Mozilla/5.0 (Linux; Android 9; Pixel 3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.90 Mobile Safari/537.36";
    
    uap.setUA(uaStr);
    var uapRes = uap.getResult();
    
    const opModelIdx = document.getElementById(cOpModelSelectId).value;
    
    // detect device model
    const device = uap.getDevice();
    if (device.model) {
        // a bug in UAParser, the number after model name is missing.  i.e. 'Pixel 3' only returns 'Pixel'
        // found more numbers after device.model.
        patt = new RegExp(device.model + "\(\[\^\)\]\+\)", "gi");
        deviceModel = patt.exec(uaStr);

        dm = deviceModel ? deviceModel[0] : device.model;
        if (deviceModel) {
            // found more numbers after device.model
            dm = deviceModel[0];
        }

        inferResultStr += "device model: " + device.vendor + " " + dm + cNewLine;
        
        inferResultStr += "device type: " + device.type + cNewLine;
        inferResultStr += cNewLine;
    } else {
        // user input for models
        inferResultStr += "System Model: [manual input]" + cNewLine;
        inferResultStr += cNewLine;
    }

    // log output
    inferResultStr += "ONNX.js Op Test - " + cModelList[opModelIdx].name + cNewLine;
    inferResultStr += "----------------------------------------------------------------------" + cNewLine;
    inferResultStr += "ONNX.js " + cOnnxjsVersion + cNewLine + cNewLine;

    // log backend info
    backend = backendSelectElem.value;
    inferResultStr += "backend: " + backend + cNewLine;
    
    // log onnx model file
    const modelUrl = cModelList[opModelIdx].model_url;
    inferResultStr += "model file: " + modelUrl + cNewLine;
    
    // onnx graph file
    inferResultStr += "<img src='" + onnxGraphElem.src + "' height='200'>" + cNewLine;

    inferResultStr += cNewLine;
    inferResultStr += "os: "      + uapRes.os.name      + " " + uapRes.os.version      + cNewLine;
    inferResultStr += "browser: " + uapRes.browser.name + " " + uapRes.browser.version + cNewLine;
    inferResultStr += "engine: "  + uapRes.engine.name  + " " + uapRes.engine.version  + cNewLine;

    inferResultStr += cNewLine;

    // log cpu arch info
    inferResultStr += "cpu arch: " + uapRes.cpu.architecture + cNewLine;

    // log gpu info
    var glCtx = glcanvas.getContext("webgl") || glcanvas.getContext("experimental-webgl");
    if (glCtx == null) {
        inferResultStr += "cannot get 'webgl' context..." + cNewLine;
    } else {
        var glInfo = glCtx.getExtension("WEBGL_debug_renderer_info");
        if (glInfo != null) {
        inferResultStr += "gpu: " + glCtx.getParameter(glInfo.UNMASKED_RENDERER_WEBGL) + cNewLine;
        } else {
        inferResultStr += "gpu: unknown" + cNewLine;
        }
    }
    inferResultStr += cNewLine;

    // create partial output text area
    const logOutputElemId = "resultLogElem";
    logOutputDiv.innerHTML = "<textarea id='" + logOutputElemId + "' readonly cols=90 rows=30></textarea>";

    // add copy button
    copyButtonDiv.innerHTML  = "<button onclick='htmlOnCopyToClipboard(" + logOutputElemId + ")'>Copy to clipboard</button>";
    //copyButtonDiv.innerHTML += "&nbsp;&nbsp;&nbsp;";

    // load & run inference
    inferResultStr += "```" + cNewLine;

    outputElem = document.getElementById(logOutputElemId);
    asyncSetHtml (outputElem, inferResultStr).then( ()=> {
        runOpTest((output)=> {
            outputElem.innerHTML += "output:" + cNewLine;
            outputElem.innerHTML += "----------------------------------------------------------------------" + cNewLine;

            const outputT = output.values().next().value;
            outputElem.innerHTML += "output tensor dimension:" + outputT.dims + cNewLine;
            outputElem.innerHTML += "output tensor size:" + outputT.size + cNewLine + cNewLine;
            
            outputElem.innerHTML += makeOutputHtml(outputT, true);

            outputElem.innerHTML += "```";

        }, (errorHtml)=>{
            outputElem.innerHTML += errorHtml;
        });
    });
}

function makeOutputHtml (outputT, isPartialOutput) {
    const cNumValues = 16
    outputHtml = "";

    if (isPartialOutput) { // partial output
        outputHtml += "row 0:" + cNewLine;
        for (var i=0; i<cNumValues; i++) {
            outputHtml += "output.data[0, " + i + "]: " + outputT.data[i] + cNewLine;
        }
        outputHtml += "... ... ..." + cNewLine + cNewLine;

        // display few floats in the middle of the image
        const rowIdx = outputT.dims[2] / 2;
        outputHtml += "row " + rowIdx + ":" + cNewLine;
        const cSkip = rowIdx * outputT.dims[3];
        for (var j=0; j<cNumValues; j++) {
            const i = j + cSkip;
            outputHtml += "output.data[" + rowIdx + "," + j + "]: " + outputT.data[i] + cNewLine;
        }
        outputHtml += "... ... ..." + cNewLine;
        outputHtml += cNewLine;
    } else { // full output, output first 16 values of each row
        alloutputHtml += "model output tensor size:" + outputT.size + cNewLine + cNewLine;
        const rowVals = outputT.size / outputT.dims[2];
        
        for (var y=0; y<outputT.size; y+=rowVals) {
            for (var x=0; x<cNumValues; x++) {
                alloutputHtml += "output.data[" + y + " + " + x + "]: " + outputT.data[y + x] + cNewLine;
            }
        }
    }

    return outputHtml;
}

function runOpTest (completeCallback, errCallback) {
    
    const backend = document.getElementById(cBackendSelectId).value;
    const opModelIdx = document.getElementById(cOpModelSelectId).value;
    
    const sess = new onnx.InferenceSession({backendHint: backend});

    const modelUrl = cModelList[opModelIdx].model_url;

    sess.loadModel(modelUrl).then(()=>{
        const n = 3;
        const h = 128;
        const w = 128;

        const x = new Float32Array(1*n*h*w);

        for (i=0; i<1*n*h*w; i++) {
            x[i] = (i%256) / 255.0;
        }

        const inputT = new onnx.Tensor(x, 'float32', [1,n,h,w]);
        
        sess.run([inputT]).then(output=>{
            completeCallback(output);
        }).catch ((e) => {
            errHtml = "!!!inference error!!! " + cNewLine + e + cNewLine;
            errCallback(errHtml);
        });
    }).catch((e)=> {
        errHtml = "!!!load error!!! " + cNewLine + e + cNewLine;
        errCallback(errHtml);
    });

}
</script>

  <!-- zero width & height canvas to get gpu info -->
  <canvas id="glcanvas" width="0" height="0"></canvas>
</body>
</html>

